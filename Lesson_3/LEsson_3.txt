_______________________________________________________________________________________________________________________________________
1.Проанализировать структуру БД vk, которую мы создали на занятии, и внести предложения по усовершенствованию (если такие идеи есть).
_______________________________________________________________________________________________________________________________________
Скорее всего "усовершенствование" в виде добавления простого текстового статуса была или будет у подавляющего большинства студентов.
По этому предлагаю ввести модифицированный статус, работающий с службой геолокации. 
Объясню идею: пользователь разрешает использование службы геолокации и распознавания местоположения приложению. Указывает конкретные координаты базовых точек,
где он может находиться (работа, дом, дача и тд, как в яндекс.картах), а служба, определяющая его (пользователя) местополение, автоматически
присваевает статусы - "На работе", "Дома", "На даче" если пользователь находится в радиусе 100 метров от указанных выше точек. Понятное дело,
что статичные точки просты в структуре, но что делать с динамическими точками, когда пользователь в пути или же зашел в кафе/кино?
Здесь можно подключить сторонние бибилиотеки сервисов, которые определяют в каком заведении пользователь может находиться, если точка координат в домашней библитеке
отсутствует. Таким сервис пользуется опять же яндекс, присылая опрос "Вам понравилось здесь?", когда пользователь впервые оказался в округе определенной геолокации.
Не всегда это работает корректно, так как опрос может придти на организацию "ИП Иванов - продажа натяжных потолков", а пользователь был в десяти метрах в табачном ларьке.
Чисто теоретический пример: пользователь соцсети находится в кинотеатре. Служба геолокации определяет его местроположение, с точностью до 30 метров (обычно кинозалы гораздо больше),
далее подключается алгоритм парсинга сайтов, посвященным расписанию и продаже билетов на сеансы кино. Алгоритм определяет, на каком сеансе находится пользователь, с учетом
текущего времени и какой фильм идет. Соцсеть автоматически выдает статус "Смотрит "Хроники Нарнии"" или же "В шоке от происходящих событий "Войны Бесконечности"".
Идея достаточно приближена к современным опосениям многих пользователей интеренета о глобальной слежке и наблюдением всевидящего ока "Большого Брата", нор продвинутым пользователем
соцсетей будет интересна.

_______________________________________________________________________________________________________________________________________
2.Добавить необходимую таблицу/таблицы для того, чтобы можно было использовать лайки для медиафайлов, постов и пользователей.
_______________________________________________________________________________________________________________________________________


-- добавим таблицу постов пользователей

CREATE TABLE posts(
	id SERIAL PRIMARY KEY,
	user_id BIGINT UNSIGNED NOT NULL,
	txt TEXT,
	metadata JSON,
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
	updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	FOREIGN KEY(user_id) REFERENCES users (id)
);

-- добавим таблицу комментариев рользователей к постам

CREATE TABLE comments(
	id SERIAL PRIMARY KEY,
	user_id BIGINT UNSIGNED NOT NULL,
	post_id BIGINT UNSIGNED NOT NULL,
	body TEXT,
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
	updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	FOREIGN KEY(user_id) REFERENCES users (id),
	FOREIGN KEY(post_id) REFERENCES posts (id)
);

-- добавим таблицу лайков пользователей

CREATE TABLE likes(
	id SERIAL PRIMARY KEY,
	from_user_id BIGINT UNSIGNED NOT NULL,
	to_post_id BIGINT UNSIGNED NOT NULL,
	to_user_id BIGINT UNSIGNED NOT NULL,
	to_media_id BIGINT UNSIGNED NOT NULL,
	to_comment_id BIGINT UNSIGNED NOT NULL,
	FOREIGN KEY(from_user_id) REFERENCES users (id),
	FOREIGN KEY(to_post_id) REFERENCES posts (id),
	FOREIGN KEY(to_user_id) REFERENCES users (id),
	FOREIGN KEY(to_media_id) REFERENCES media (id),
	FOREIGN KEY(to_comment_id) REFERENCES comments (id),
	INDEX like_to_media_idx (from_user_id, to_media_id),
	INDEX like_post_idx (from_user_id, to_post_id),
	INDEX like_user_idx (from_user_id, to_user_id),
	INDEX like_comment_idx (from_user_id, to_comment_id)
);
